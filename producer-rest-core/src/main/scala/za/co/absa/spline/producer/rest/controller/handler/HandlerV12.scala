/*
 * Copyright 2019 ABSA Group Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package za.co.absa.spline.producer.rest.controller.handler

import io.swagger.annotations.{Api, ApiOperation, ApiResponse, ApiResponses}
import org.springframework.http.HttpStatus
import org.springframework.web.bind.annotation.{PostMapping, RequestBody, ResponseBody, ResponseStatus}
import za.co.absa.spline.producer.model.v1_2
import za.co.absa.spline.producer.modelmapper.v1_2.ModelMapperV12
import za.co.absa.spline.producer.rest.ProducerAPI.MimeTypeV12
import za.co.absa.spline.producer.rest.controller.IngestionController

import java.util.UUID
import scala.concurrent.Future

trait HandlerV12 {
  this: IngestionController =>

  private final val MimeType = MimeTypeV12
  private final val mapper = ModelMapperV12

  @Api(tags = Array("execution"))
  @ApiOperation(
    value = "Save Execution Plan",
    notes =
      """
        Saves an Execution Plan and returns its new UUID.

        Payload format:

        {
          // [Optional] Global unique identifier of the execution plan. If omitted, will be generated by the server.
          id: <UUID>,

          // [Optional] A name of the application (script, job etc) that this execution plan represents.
          name: <string>,

          // [Optional] A label that logically distinguish a group of one of multiple execution plans from another group.
          // If set, it has to match the discriminator of the associated execution events.
          // The property is used for UUID collision detection.
          discriminator: <string>,

          // Operation level lineage info
          operations: {

            // Write operation
            write: {
              // Operation ID (should be unique in the scope of the current execution plan)
              id: <string>,
              // [Optional] Operation name
              name: <string>,
              // Destination URI, where the data has been written to
              outputSource: <URI>,
              // Shows if the write operation appended or replaced the data in the target destination
              append: <boolean>,
              // Array of preceding operations IDs,
              // i.e. operations that serves as an input for the current operation
              childIds: [<string>],
              // [Optional] Operation parameters
              params: {...},
              // [Optional] Custom info about the operation
              extra: {...}
            },

            // Array of read operations
            reads: [
              {
                // Operation ID (see above)
                id: <string>,
                // [Optional] Operation name
                name: <string>,
                // Source URIs, where the data has been read from
                inputSources: [<URI>],
                // [Optional] Output attribute IDs
                output: [<string>],
                // [Optional] Operation parameters
                params: {...},
                // [Optional] Custom info about the operation
                extra: {...}
              },
              ...
            ],

            // Other operations
            other: [
              {
                // Operation ID (see above)
                id: <string>,
                // [Optional] Operation name
                name: <string>,
                // Array of preceding operations IDs (see above)
                childIds: [<string>],
                // [Optional] Output attribute IDs. If output is undefined the server will try to infer it from the child operations' output.
                output: [<string>],
                // [Optional] Operation parameters
                params: {...},
                // [Optional] Custom info about the operation
                extra: {...}
              },
              ...
            ]
          },

          // [Optional] Attribute definitions
          attributes: [
            {
              id: <string>,
              // Attribute name
              name: <string>,
              // [Optional] References to other attributes, expressions or constants that this attribute is computed from
              childRefs: [ { __exprId: <string> } | { __attrId: <string> } ],
              // [Optional] Custom info
              extra: {...}
            }
          ],

          // [Optional] Attribute level lineage info
          expressions: {

            // Function definitions
            functions: [
              {
                id: <string>,
                // Function name
                name: <string>,
                // [Optional] References to operands (expressions, constants or attributes)
                childRefs: [ { __exprId: <string> } | { __attrId: <string> } ],
                // [Optional] Named expression parameters
                params: {...},
                // [Optional] Custom meta info
                extra: {...}
              }
            ],

            // Constant/Literal definitions
            constants: {
              {
                id: <string>,
                // constant value
                value: <any>,
                // [Optional] Custom meta info
                extra: {...}
              }
            }
          },

          // Information about the data framework in use (e.g. Spark, StreamSets etc)
          systemInfo: {
            name: <string>,
            version: <string>
          },

          // [Optional] Spline agent information
          agentInfo: {
            name: <string>,
            version: <string>
          },

          // [Optional] Any other extra info associated with the current execution plan
          extraInfo: {...}
        }
      """)
  @ApiResponses(Array(
    new ApiResponse(code = 201, message = "Execution Plan is stored with the UUID returned in a response body")
  ))
  @ResponseStatus(HttpStatus.CREATED)
  @ResponseBody
  @PostMapping(path = Array("/execution-plans"), consumes = Array(MimeType))
  def planHandler(@RequestBody planDTO: v1_2.ExecutionPlan): Future[UUID] = {
    processPlan[v1_2.ExecutionPlan](planDTO, mapper)
  }

  @Api(tags = Array("execution"))
  @ApiOperation(
    value = "Save Execution Events",
    notes =
      """
        Saves a list of Execution Events.

        Payload format:

        [
          {
            // Reference to the execution plan Id that was triggered
            planId: <UUID>,

            // [Optional] A label that logically distinguish a group of one of multiple execution plans from another group.
            // If set, it has to match the discriminator of the associated execution plan.
            // The property is used for UUID collision detection.
            discriminator: <string>,

            // Time (milliseconds since Epoch) when the execution finished
            timestamp: <number>,

            // [Optional] Duration (in nanoseconds) of the execution
            durationNs: <number>,
            // [Optional] Additional info about the error (in case there was an error during the execution)
            error: {...},

            // [Optional] Any other extra information related to the given execution event
            extra: {...}
          },
          ...
        ]
      """)
  @ApiResponses(Array(
    new ApiResponse(code = 201, message = "All execution Events are successfully stored")
  ))
  @ResponseStatus(HttpStatus.CREATED)
  @PostMapping(path = Array("/execution-events"), consumes = Array(MimeType))
  def eventsHandler(@RequestBody eventDTOs: Array[v1_2.ExecutionEvent]): Future[Unit] = {
    processEvents(eventDTOs, mapper)
  }

}
